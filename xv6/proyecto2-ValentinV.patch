Los archivos binarios xv6-unrc/._asm.h y xv6-mod/._asm.h son distintos
Los archivos binarios xv6-unrc/._bio.c y xv6-mod/._bio.c son distintos
diff -rupN xv6-unrc/.bochsrc xv6-mod/.bochsrc
--- xv6-unrc/.bochsrc	1969-12-31 21:00:00.000000000 -0300
+++ xv6-mod/.bochsrc	2018-04-18 17:43:18.393432013 -0300
@@ -0,0 +1,738 @@
+# You may now use double quotes around pathnames, in case
+# your pathname includes spaces.
+
+#=======================================================================
+# CONFIG_INTERFACE
+#
+# The configuration interface is a series of menus or dialog boxes that
+# allows you to change all the settings that control Bochs's behavior.
+# There are two choices of configuration interface: a text mode version
+# called "textconfig" and a graphical version called "wx".  The text
+# mode version uses stdin/stdout and is always compiled in.  The graphical
+# version is only available when you use "--with-wx" on the configure 
+# command.  If you do not write a config_interface line, Bochs will 
+# choose a default for you.
+#
+# NOTE: if you use the "wx" configuration interface, you must also use
+# the "wx" display library.
+#=======================================================================
+#config_interface: textconfig
+#config_interface: wx
+
+#=======================================================================
+# DISPLAY_LIBRARY
+#
+# The display library is the code that displays the Bochs VGA screen.  Bochs 
+# has a selection of about 10 different display library implementations for 
+# different platforms.  If you run configure with multiple --with-* options, 
+# the display_library command lets you choose which one you want to run with.
+# If you do not write a display_library line, Bochs will choose a default for
+# you.
+#
+# The choices are: 
+#   x              use X windows interface, cross platform
+#   win32          use native win32 libraries
+#   carbon         use Carbon library (for MacOS X)
+#   beos           use native BeOS libraries
+#   macintosh      use MacOS pre-10
+#   amigaos        use native AmigaOS libraries
+#   sdl            use SDL library, cross platform
+#   svga           use SVGALIB library for Linux, allows graphics without X11
+#   term           text only, uses curses/ncurses library, cross platform
+#   rfb            provides an interface to AT&T's VNC viewer, cross platform
+#   wx             use wxWidgets library, cross platform
+#   nogui          no display at all
+#
+# NOTE: if you use the "wx" configuration interface, you must also use
+# the "wx" display library.
+#
+# Specific options:
+# Some display libraries now support specific option to control their
+# behaviour. See the examples below for currently supported options.
+#=======================================================================
+#display_library: amigaos
+#display_library: beos
+#display_library: carbon
+#display_library: macintosh
+#display_library: nogui
+#display_library: rfb, options="timeout=60" # time to wait for client
+#display_library: sdl, options="fullscreen" # startup in fullscreen mode
+#display_library: term
+#display_library: win32, options="legacyF12" # use F12 to toggle mouse
+#display_library: wx
+#display_library: x
+
+#=======================================================================
+# ROMIMAGE:
+# The ROM BIOS controls what the PC does when it first powers on.
+# Normally, you can use a precompiled BIOS in the source or binary
+# distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded
+# starting at address 0xf0000, and it is exactly 64k long.
+# You can also use the environment variable $BXSHARE to specify the
+# location of the BIOS.
+# The usage of external large BIOS images (up to 512k) at memory top is
+# now supported, but we still recommend to use the BIOS distributed with
+# Bochs. Now the start address can be calculated from image size.
+#=======================================================================
+romimage: file=$BXSHARE/BIOS-bochs-latest
+#romimage: file=mybios.bin, address=0xfff80000 # 512k at memory top
+#romimage: file=mybios.bin # calculate start address from image size
+
+#=======================================================================
+# CPU:
+# This defines cpu-related parameters inside Bochs:
+#
+#  COUNT:
+#  Set the number of processors when Bochs is compiled for SMP emulation.
+#  Bochs currently supports up to 8 processors. If Bochs is compiled
+#  without SMP support, it won't accept values different from 1.
+#
+#  IPS:
+#  Emulated Instructions Per Second.  This is the number of IPS that bochs
+#  is capable of running on your machine. You can recompile Bochs with
+#  --enable-show-ips option enabled, to find your workstation's capability.
+#  Measured IPS value will then be logged into your log file or status bar
+#  (if supported by the gui).
+#
+#  IPS is used to calibrate many time-dependent events within the bochs 
+#  simulation.  For example, changing IPS affects the frequency of VGA
+#  updates, the duration of time before a key starts to autorepeat, and
+#  the measurement of BogoMips and other benchmarks.
+#
+#  Examples:
+#  Machine                                         Mips
+# ________________________________________________________________
+#  2.1Ghz Athlon XP with Linux 2.6/g++ 3.4         12 to 15 Mips
+#  1.6Ghz Intel P4 with Win2000/g++ 3.3             5 to  7 Mips
+#  650Mhz Athlon K-7 with Linux 2.4.4/egcs-2.91.66  2 to  2.5 Mips
+#  400Mhz Pentium II with Linux 2.0.36/egcs-1.0.3   1 to  1.8 Mips
+#=======================================================================
+cpu: count=2, ips=10000000
+
+#=======================================================================
+# MEGS
+# Set the number of Megabytes of physical memory you want to emulate. 
+# The default is 32MB, most OS's won't need more than that.
+# The maximum amount of memory supported is 2048Mb.
+#=======================================================================
+#megs: 256
+#megs: 128
+#megs: 64
+megs: 32
+#megs: 16
+#megs: 8
+
+#=======================================================================
+# OPTROMIMAGE[1-4]:
+# You may now load up to 4 optional ROM images. Be sure to use a 
+# read-only area, typically between C8000 and EFFFF. These optional
+# ROM images should not overwrite the rombios (located at
+# F0000-FFFFF) and the videobios (located at C0000-C7FFF).
+# Those ROM images will be initialized by the bios if they contain 
+# the right signature (0x55AA) and a valid checksum.
+# It can also be a convenient way to upload some arbitrary code/data
+# in the simulation, that can be retrieved by the boot loader
+#=======================================================================
+#optromimage1: file=optionalrom.bin, address=0xd0000
+#optromimage2: file=optionalrom.bin, address=0xd1000
+#optromimage3: file=optionalrom.bin, address=0xd2000
+#optromimage4: file=optionalrom.bin, address=0xd3000
+
+#optramimage1: file=/path/file1.img, address=0x0010000
+#optramimage2: file=/path/file2.img, address=0x0020000
+#optramimage3: file=/path/file3.img, address=0x0030000
+#optramimage4: file=/path/file4.img, address=0x0040000
+
+#=======================================================================
+# VGAROMIMAGE
+# You now need to load a VGA ROM BIOS into C0000.
+#=======================================================================
+#vgaromimage: file=bios/VGABIOS-elpin-2.40
+vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
+#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus
+
+#=======================================================================
+# VGA:
+# Here you can specify the display extension to be used. With the value
+# 'none' you can use standard VGA with no extension. Other supported
+# values are 'vbe' for Bochs VBE and 'cirrus' for Cirrus SVGA support.
+#=======================================================================
+#vga: extension=cirrus
+#vga: extension=vbe
+vga: extension=none
+
+#=======================================================================
+# FLOPPYA:
+# Point this to pathname of floppy image file or device
+# This should be of a bootable floppy(image/device) if you're
+# booting from 'a' (or 'floppy').
+#
+# You can set the initial status of the media to 'ejected' or 'inserted'.
+#   floppya: 2_88=path, status=ejected             (2.88M 3.5" floppy)
+#   floppya: 1_44=path, status=inserted            (1.44M 3.5" floppy)
+#   floppya: 1_2=path, status=ejected              (1.2M  5.25" floppy)
+#   floppya: 720k=path, status=inserted            (720K  3.5" floppy)
+#   floppya: 360k=path, status=inserted            (360K  5.25" floppy)
+#   floppya: 320k=path, status=inserted            (320K  5.25" floppy)
+#   floppya: 180k=path, status=inserted            (180K  5.25" floppy)
+#   floppya: 160k=path, status=inserted            (160K  5.25" floppy)
+#   floppya: image=path, status=inserted           (guess type from image size)
+#
+# The path should be the name of a disk image file.  On Unix, you can use a raw
+# device name such as /dev/fd0 on Linux.  On win32 platforms, use drive letters
+# such as a: or b: as the path.  The parameter 'image' works with image files
+# only. In that case the size must match one of the supported types.
+#=======================================================================
+floppya: 1_44=/dev/fd0, status=inserted
+#floppya: image=../1.44, status=inserted
+#floppya: 1_44=/dev/fd0H1440, status=inserted
+#floppya: 1_2=../1_2, status=inserted
+#floppya: 1_44=a:, status=inserted
+#floppya: 1_44=a.img, status=inserted
+#floppya: 1_44=/dev/rfd0a, status=inserted
+
+#=======================================================================
+# FLOPPYB:
+# See FLOPPYA above for syntax
+#=======================================================================
+#floppyb: 1_44=b:, status=inserted
+floppyb: 1_44=b.img, status=inserted
+
+#=======================================================================
+# ATA0, ATA1, ATA2, ATA3
+# ATA controller for hard disks and cdroms
+#
+# ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
+# 
+# These options enables up to 4 ata channels. For each channel
+# the two base io addresses and the irq must be specified.
+# 
+# ata0 and ata1 are enabled by default with the values shown below
+#
+# Examples:
+#   ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
+#   ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
+#   ata2: enabled=1, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
+#   ata3: enabled=1, ioaddr1=0x168, ioaddr2=0x360, irq=9
+#=======================================================================
+ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
+ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
+ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
+ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9
+
+#=======================================================================
+# ATA[0-3]-MASTER, ATA[0-3]-SLAVE
+#
+# This defines the type and characteristics of all attached ata devices:
+#   type=       type of attached device [disk|cdrom] 
+#   mode=       only valid for disks [flat|concat|external|dll|sparse|vmware3]
+#   mode=       only valid for disks [undoable|growing|volatile]
+#   path=       path of the image
+#   cylinders=  only valid for disks
+#   heads=      only valid for disks
+#   spt=        only valid for disks
+#   status=     only valid for cdroms [inserted|ejected]
+#   biosdetect= type of biosdetection [none|auto], only for disks on ata0 [cmos]
+#   translation=type of translation of the bios, only for disks [none|lba|large|rechs|auto]
+#   model=      string returned by identify device command
+#   journal=    optional filename of the redolog for undoable and volatile disks
+#   
+# Point this at a hard disk image file, cdrom iso file, or physical cdrom
+# device.  To create a hard disk image, try running bximage.  It will help you
+# choose the size and then suggest a line that works with it.
+#
+# In UNIX it may be possible to use a raw device as a Bochs hard disk, 
+# but WE DON'T RECOMMEND IT.  In Windows there is no easy way.
+#
+# In windows, the drive letter + colon notation should be used for cdroms.
+# Depending on versions of windows and drivers, you may only be able to 
+# access the "first" cdrom in the system.  On MacOSX, use path="drive"
+# to access the physical drive.
+#
+# The path is always mandatory. For flat hard disk images created with
+# bximage geometry autodetection can be used (cylinders=0 -> cylinders are
+# calculated using heads=16 and spt=63). For other hard disk images and modes
+# the cylinders, heads, and spt are mandatory.
+#
+# Default values are:
+#   mode=flat, biosdetect=auto, translation=auto, model="Generic 1234"
+#
+# The biosdetect option has currently no effect on the bios
+#
+# Examples:
+#   ata0-master: type=disk, mode=flat, path=10M.sample, cylinders=306, heads=4, spt=17
+#   ata0-slave:  type=disk, mode=flat, path=20M.sample, cylinders=615, heads=4, spt=17
+#   ata1-master: type=disk, mode=flat, path=30M.sample, cylinders=615, heads=6, spt=17
+#   ata1-slave:  type=disk, mode=flat, path=46M.sample, cylinders=940, heads=6, spt=17
+#   ata2-master: type=disk, mode=flat, path=62M.sample, cylinders=940, heads=8, spt=17
+#   ata2-slave:  type=disk, mode=flat, path=112M.sample, cylinders=900, heads=15, spt=17
+#   ata3-master: type=disk, mode=flat, path=483M.sample, cylinders=1024, heads=15, spt=63
+#   ata3-slave:  type=cdrom, path=iso.sample, status=inserted
+#=======================================================================
+ata0-master: type=disk, mode=flat, path="xv6.img", cylinders=100, heads=10, spt=10
+ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
+#ata0-slave: type=cdrom, path=D:, status=inserted
+#ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
+#ata0-slave: type=cdrom, path="drive", status=inserted
+#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
+
+#=======================================================================
+# BOOT:
+# This defines the boot sequence. Now you can specify up to 3 boot drives.
+# You can either boot from 'floppy', 'disk' or 'cdrom'
+# legacy 'a' and 'c' are also supported
+# Examples:
+#   boot: floppy
+#   boot: disk
+#   boot: cdrom
+#   boot: c
+#   boot: a
+#   boot: cdrom, floppy, disk
+#=======================================================================
+#boot: floppy
+boot: disk
+
+#=======================================================================
+# CLOCK:
+# This defines the parameters of the clock inside Bochs:
+#
+#  SYNC:
+#  TO BE COMPLETED (see Greg explanation in feature request #536329)
+#
+#  TIME0:
+#  Specifies the start (boot) time of the virtual machine. Use a time 
+#  value as returned by the time(2) system call. If no time0 value is 
+#  set or if time0 equal to 1 (special case) or if time0 equal 'local', 
+#  the simulation will be started at the current local host time.
+#  If time0 equal to 2 (special case) or if time0 equal 'utc',
+#  the simulation will be started at the current utc time.
+#
+# Syntax:
+#  clock: sync=[none|slowdown|realtime|both], time0=[timeValue|local|utc]
+#
+# Example:
+#   clock: sync=none,     time0=local       # Now (localtime)
+#   clock: sync=slowdown, time0=315529200   # Tue Jan  1 00:00:00 1980
+#   clock: sync=none,     time0=631148400   # Mon Jan  1 00:00:00 1990
+#   clock: sync=realtime, time0=938581955   # Wed Sep 29 07:12:35 1999
+#   clock: sync=realtime, time0=946681200   # Sat Jan  1 00:00:00 2000
+#   clock: sync=none,     time0=1           # Now (localtime)
+#   clock: sync=none,     time0=utc         # Now (utc/gmt)
+# 
+# Default value are sync=none, time0=local
+#=======================================================================
+#clock: sync=none, time0=local
+
+
+#=======================================================================
+# FLOPPY_BOOTSIG_CHECK: disabled=[0|1]
+# Enables or disables the 0xaa55 signature check on boot floppies
+# Defaults to disabled=0
+# Examples:
+#   floppy_bootsig_check: disabled=0
+#   floppy_bootsig_check: disabled=1
+#=======================================================================
+#floppy_bootsig_check: disabled=1
+floppy_bootsig_check: disabled=0
+
+#=======================================================================
+# LOG:
+# Give the path of the log file you'd like Bochs debug and misc. verbiage
+# to be written to. If you don't use this option or set the filename to
+# '-' the output is written to the console. If you really don't want it,
+# make it "/dev/null" (Unix) or "nul" (win32). :^(
+#
+# Examples:
+#   log: ./bochs.out
+#   log: /dev/tty
+#=======================================================================
+#log: /dev/null
+log: bochsout.txt
+
+#=======================================================================
+# LOGPREFIX:
+# This handles the format of the string prepended to each log line.
+# You may use those special tokens :
+#   %t : 11 decimal digits timer tick
+#   %i : 8 hexadecimal digits of cpu current eip (ignored in SMP configuration)
+#   %e : 1 character event type ('i'nfo, 'd'ebug, 'p'anic, 'e'rror)
+#   %d : 5 characters string of the device, between brackets
+# 
+# Default : %t%e%d
+# Examples:
+#   logprefix: %t-%e-@%i-%d
+#   logprefix: %i%e%d
+#=======================================================================
+#logprefix: %t%e%d
+
+#=======================================================================
+# LOG CONTROLS
+#
+# Bochs now has four severity levels for event logging.
+#   panic: cannot proceed.  If you choose to continue after a panic, 
+#          don't be surprised if you get strange behavior or crashes.
+#   error: something went wrong, but it is probably safe to continue the
+#          simulation.
+#   info: interesting or useful messages.
+#   debug: messages useful only when debugging the code.  This may
+#          spit out thousands per second.
+#
+# For events of each level, you can choose to crash, report, or ignore.
+# TODO: allow choice based on the facility: e.g. crash on panics from
+#       everything except the cdrom, and only report those.
+#
+# If you are experiencing many panics, it can be helpful to change
+# the panic action to report instead of fatal.  However, be aware
+# that anything executed after a panic is uncharted territory and can 
+# cause bochs to become unstable.  The panic is a "graceful exit," so
+# if you disable it you may get a spectacular disaster instead.
+#=======================================================================
+panic: action=ask
+error: action=report
+info: action=report
+debug: action=ignore
+#pass: action=fatal
+
+#=======================================================================
+# DEBUGGER_LOG:
+# Give the path of the log file you'd like Bochs to log debugger output.
+# If you really don't want it, make it /dev/null or '-'. :^(
+#
+# Examples:
+#   debugger_log: ./debugger.out
+#=======================================================================
+#debugger_log: /dev/null
+#debugger_log: debugger.out
+debugger_log: -
+
+#=======================================================================
+# COM1, COM2, COM3, COM4:
+# This defines a serial port (UART type 16550A). In the 'term' you can specify
+# a device to use as com1. This can be a real serial line, or a pty.  To use
+# a pty (under X/Unix), create two windows (xterms, usually).  One of them will
+# run bochs, and the other will act as com1. Find out the tty the com1
+# window using the `tty' command, and use that as the `dev' parameter.
+# Then do `sleep 1000000' in the com1 window to keep the shell from
+# messing with things, and run bochs in the other window.  Serial I/O to
+# com1 (port 0x3f8) will all go to the other window.
+# Other serial modes are 'null' (no input/output), 'file' (output to a file
+# specified as the 'dev' parameter), 'raw' (use the real serial port - under
+# construction for win32), 'mouse' (standard serial mouse - requires
+# mouse option setting 'type=serial' or 'type=serial_wheel') and 'socket'
+# (connect a networking socket).
+#
+# Examples:
+#   com1: enabled=1, mode=null
+#   com1: enabled=1, mode=mouse
+#   com2: enabled=1, mode=file, dev=serial.out
+#   com3: enabled=1, mode=raw, dev=com1
+#   com3: enabled=1, mode=socket, dev=localhost:8888
+#=======================================================================
+#com1: enabled=1, mode=term, dev=/dev/ttyp9
+
+
+#=======================================================================
+# PARPORT1, PARPORT2:
+# This defines a parallel (printer) port. When turned on and an output file is
+# defined the emulated printer port sends characters printed by the guest OS
+# into the output file. On some platforms a device filename can be used to
+# send the data to the real parallel port (e.g. "/dev/lp0" on Linux, "lpt1" on
+# win32 platforms).
+#
+# Examples:
+#   parport1: enabled=1, file="parport.out"
+#   parport2: enabled=1, file="/dev/lp0"
+#   parport1: enabled=0
+#=======================================================================
+parport1: enabled=1, file="/dev/stdout"
+
+#=======================================================================
+# SB16:
+# This defines the SB16 sound emulation. It can have several of the
+# following properties.
+# All properties are in the format sb16: property=value
+# midi: The filename is where the midi data is sent. This can be a
+#       device or just a file if you want to record the midi data.
+# midimode:
+#      0=no data
+#      1=output to device (system dependent. midi denotes the device driver)
+#      2=SMF file output, including headers
+#      3=output the midi data stream to the file (no midi headers and no
+#        delta times, just command and data bytes)
+# wave: This is the device/file where wave output is stored
+# wavemode:
+#      0=no data
+#      1=output to device (system dependent. wave denotes the device driver)
+#      2=VOC file output, incl. headers
+#      3=output the raw wave stream to the file
+# log:  The file to write the sb16 emulator messages to.
+# loglevel:
+#      0=no log
+#      1=resource changes, midi program and bank changes
+#      2=severe errors
+#      3=all errors
+#      4=all errors plus all port accesses
+#      5=all errors and port accesses plus a lot of extra info
+# dmatimer:
+#      microseconds per second for a DMA cycle.  Make it smaller to fix
+#      non-continuous sound.  750000 is usually a good value.  This needs a
+#      reasonably correct setting for the IPS parameter of the CPU option.
+#
+# For an example look at the next line:
+#=======================================================================
+
+#sb16: midimode=1, midi=/dev/midi00, wavemode=1, wave=/dev/dsp, loglevel=2, log=sb16.log, dmatimer=600000
+
+#=======================================================================
+# VGA_UPDATE_INTERVAL:
+# Video memory is scanned for updates and screen updated every so many
+# virtual seconds.  The default is 40000, about 25Hz. Keep in mind that
+# you must tweak the 'cpu: ips=N' directive to be as close to the number
+# of emulated instructions-per-second your workstation can do, for this
+# to be accurate.
+#
+# Examples:
+#   vga_update_interval: 250000
+#=======================================================================
+vga_update_interval: 300000
+
+# using for Winstone '98 tests
+#vga_update_interval:  100000
+
+#=======================================================================
+# KEYBOARD_SERIAL_DELAY:
+# Approximate time in microseconds that it takes one character to
+# be transfered from the keyboard to controller over the serial path.
+# Examples:
+#   keyboard_serial_delay: 200
+#=======================================================================
+keyboard_serial_delay: 250
+
+#=======================================================================
+# KEYBOARD_PASTE_DELAY:
+# Approximate time in microseconds between attempts to paste
+# characters to the keyboard controller. This leaves time for the
+# guest os to deal with the flow of characters.  The ideal setting
+# depends on how your operating system processes characters.  The
+# default of 100000 usec (.1 seconds) was chosen because it works 
+# consistently in Windows.
+#
+# If your OS is losing characters during a paste, increase the paste
+# delay until it stops losing characters.
+#
+# Examples:
+#   keyboard_paste_delay: 100000
+#=======================================================================
+keyboard_paste_delay: 100000
+
+#=======================================================================
+# MOUSE: 
+# This option prevents Bochs from creating mouse "events" unless a mouse
+# is  enabled. The hardware emulation itself is not disabled by this.
+# You can turn the mouse on by setting enabled to 1, or turn it off by
+# setting enabled to 0. Unless you have a particular reason for enabling
+# the mouse by default, it is recommended that you leave it off.
+# You can also toggle the mouse usage at runtime (control key + middle
+# mouse button on X11, SDL, wxWidgets and Win32).
+# With the mouse type option you can select the type of mouse to emulate.
+# The default value is 'ps2'. The other choices are 'imps2' (wheel mouse
+# on PS/2), 'serial', 'serial_wheel' (one com port requires setting
+# 'mode=mouse') and 'usb' (3-button mouse - one of the USB ports must be
+# connected with the 'mouse' device - requires PCI and USB support).
+#
+# Examples:
+#   mouse: enabled=1
+#   mouse: enabled=1, type=imps2
+#   mouse: enabled=1, type=serial
+#   mouse: enabled=0
+#=======================================================================
+mouse: enabled=0
+
+#=======================================================================
+# private_colormap: Request that the GUI create and use it's own
+#                   non-shared colormap.  This colormap will be used
+#                   when in the bochs window.  If not enabled, a
+#                   shared colormap scheme may be used.  Not implemented
+#                   on all GUI's.
+#
+# Examples:
+#   private_colormap: enabled=1
+#   private_colormap: enabled=0
+#=======================================================================
+private_colormap: enabled=0
+
+#=======================================================================
+# fullscreen: ONLY IMPLEMENTED ON AMIGA
+#             Request that Bochs occupy the entire screen instead of a 
+#             window.
+#
+# Examples:
+#   fullscreen: enabled=0
+#   fullscreen: enabled=1
+#=======================================================================
+#fullscreen: enabled=0
+#screenmode: name="sample"
+
+#=======================================================================
+# ne2k: NE2000 compatible ethernet adapter
+#
+# Examples:
+# ne2k: ioaddr=IOADDR, irq=IRQ, mac=MACADDR, ethmod=MODULE, ethdev=DEVICE, script=SCRIPT
+#
+# ioaddr, irq: You probably won't need to change ioaddr and irq, unless there
+# are IRQ conflicts.
+#
+# mac: The MAC address MUST NOT match the address of any machine on the net.
+# Also, the first byte must be an even number (bit 0 set means a multicast
+# address), and you cannot use ff:ff:ff:ff:ff:ff because that's the broadcast
+# address.  For the ethertap module, you must use fe:fd:00:00:00:01.  There may
+# be other restrictions too.  To be safe, just use the b0:c4... address.
+#
+# ethdev: The ethdev value is the name of the network interface on your host
+# platform.  On UNIX machines, you can get the name by running ifconfig.  On
+# Windows machines, you must run niclist to get the name of the ethdev.
+# Niclist source code is in misc/niclist.c and it is included in Windows 
+# binary releases.
+#
+# script: The script value is optional, and is the name of a script that 
+# is executed after bochs initialize the network interface. You can use 
+# this script to configure this network interface, or enable masquerading.
+# This is mainly useful for the tun/tap devices that only exist during
+# Bochs execution. The network interface name is supplied to the script
+# as first parameter
+#
+# If you don't want to make connections to any physical networks,
+# you can use the following 'ethmod's to simulate a virtual network.
+#   null: All packets are discarded, but logged to a few files.
+#   arpback: ARP is simulated. Disabled by default.
+#   vde:  Virtual Distributed Ethernet
+#   vnet: ARP, ICMP-echo(ping), DHCP and read/write TFTP are simulated.
+#         The virtual host uses 192.168.10.1.
+#         DHCP assigns 192.168.10.2 to the guest.
+#         TFTP uses the ethdev value for the root directory and doesn't
+#         overwrite files.
+#
+#=======================================================================
+# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=fbsd, ethdev=en0 #macosx
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=fbsd, ethdev=xl0
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=linux, ethdev=eth0
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=win32, ethdev=MYCARD
+# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tap, ethdev=tap0
+# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tuntap, ethdev=/dev/net/tun0, script=./tunconfig
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=null, ethdev=eth0
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vde, ethdev="/tmp/vde.ctl"
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vnet, ethdev="c:/temp"
+
+#=======================================================================
+# KEYBOARD_MAPPING:
+# This enables a remap of a physical localized keyboard to a 
+# virtualized us keyboard, as the PC architecture expects.
+# If enabled, the keymap file must be specified.
+# 
+# Examples:
+#   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
+#=======================================================================
+keyboard_mapping: enabled=0, map=
+
+#=======================================================================
+# KEYBOARD_TYPE:
+# Type of keyboard return by a "identify keyboard" command to the
+# keyboard controler. It must be one of "xt", "at" or "mf".
+# Defaults to "mf". It should be ok for almost everybody. A known
+# exception is french macs, that do have a "at"-like keyboard.
+#
+# Examples:
+#   keyboard_type: mf
+#=======================================================================
+#keyboard_type: mf
+
+#=======================================================================
+# USER_SHORTCUT:
+# This defines the keyboard shortcut to be sent when you press the "user"
+# button in the headerbar. The shortcut string is a combination of maximum
+# 3 key names (listed below) separated with a '-' character. The old-style
+# syntax (without the '-') still works for the key combinations supported
+# in Bochs 2.2.1.
+# Valid key names:
+# "alt", "bksl", "bksp", "ctrl", "del", "down", "end", "enter", "esc",
+# "f1", ... "f12", "home", "ins", "left", "menu", "minus", "pgdwn", "pgup",
+# "plus", "right", "shift", "space", "tab", "up", and "win".
+#
+# Example:
+#   user_shortcut: keys=ctrl-alt-del
+#=======================================================================
+#user_shortcut: keys=ctrl-alt-del
+
+#=======================================================================
+# I440FXSUPPORT:
+# This option controls the presence of the i440FX PCI chipset. You can
+# also specify the devices connected to PCI slots. Up to 5 slots are
+# available now. These devices are currently supported: ne2k, pcivga,
+# pcidev and pcipnic. If Bochs is compiled with Cirrus SVGA support
+# you'll have the additional choice 'cirrus'.
+#
+# Example:
+#   i440fxsupport: enabled=1, slot1=pcivga, slot2=ne2k
+#=======================================================================
+#i440fxsupport: enabled=1
+
+#=======================================================================
+# USB1:
+# This option controls the presence of the USB root hub which is a part
+# of the i440FX PCI chipset. With the portX option you can connect devices
+# to the hub (currently supported: 'mouse' and 'keypad'). If you connect
+# the mouse to one of the ports and use the mouse option 'type=usb' you'll
+# have a 3-button USB mouse.
+#
+# Example:
+#   usb1: enabled=1, port1=mouse, port2=keypad
+#=======================================================================
+#usb1: enabled=1
+
+#=======================================================================
+# CMOSIMAGE:
+# This defines image file that can be loaded into the CMOS RAM at startup.
+# The rtc_init parameter controls whether initialize the RTC with values stored
+# in the image. By default the time0 argument given to the clock option is used.
+# With 'rtc_init=image' the image is the source for the initial time.
+#
+# Example:
+#   cmosimage: file=cmos.img, rtc_init=image
+#=======================================================================
+#cmosimage: file=cmos.img, rtc_init=time0
+
+#=======================================================================
+# other stuff
+#=======================================================================
+#magic_break: enabled=1
+#load32bitOSImage: os=nullkernel, path=../kernel.img, iolog=../vga_io.log
+#load32bitOSImage: os=linux, path=../linux.img, iolog=../vga_io.log, initrd=../initrd.img
+#text_snapshot_check: enable
+
+#-------------------------
+# PCI host device mapping
+#-------------------------
+#pcidev: vendor=0x1234, device=0x5678
+
+#=======================================================================
+# GDBSTUB:
+# Enable GDB stub. See user documentation for details.
+# Default value is enabled=0.
+#=======================================================================
+#gdbstub: enabled=0, port=1234, text_base=0, data_base=0, bss_base=0
+
+#=======================================================================
+# IPS:
+# The IPS directive is DEPRECATED. Use the parameter IPS of the CPU
+# directive instead.
+#=======================================================================
+#ips: 10000000
+
+#=======================================================================
+# for Macintosh, use the style of pathnames in the following
+# examples.
+#
+# vgaromimage: :bios:VGABIOS-elpin-2.40
+# romimage: file=:bios:BIOS-bochs-latest, address=0xf0000
+# floppya: 1_44=[fd:], status=inserted
+#=======================================================================
Los archivos binarios xv6-unrc/._bootasm.S y xv6-mod/._bootasm.S son distintos
Los archivos binarios xv6-unrc/._bootmain.c y xv6-mod/._bootmain.c son distintos
Los archivos binarios xv6-unrc/._buf.h y xv6-mod/._buf.h son distintos
Los archivos binarios xv6-unrc/._BUGS y xv6-mod/._BUGS son distintos
Los archivos binarios xv6-unrc/._console.c y xv6-mod/._console.c son distintos
Los archivos binarios xv6-unrc/._cuth y xv6-mod/._cuth son distintos
Los archivos binarios xv6-unrc/._date.h y xv6-mod/._date.h son distintos
Los archivos binarios xv6-unrc/._defs.h y xv6-mod/._defs.h son distintos
diff -rupN xv6-unrc/defs.h xv6-mod/defs.h
--- xv6-unrc/defs.h	2018-04-18 17:43:18.445432823 -0300
+++ xv6-mod/defs.h	2018-04-18 19:25:07.333604435 -0300
@@ -118,6 +118,7 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+void            aging(void);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
Los archivos binarios xv6-unrc/._dot-bochsrc y xv6-mod/._dot-bochsrc son distintos
Los archivos binarios xv6-unrc/._elf.h y xv6-mod/._elf.h son distintos
Los archivos binarios xv6-unrc/._entryother.S y xv6-mod/._entryother.S son distintos
Los archivos binarios xv6-unrc/._entry.S y xv6-mod/._entry.S son distintos
Los archivos binarios xv6-unrc/._exec.c y xv6-mod/._exec.c son distintos
Los archivos binarios xv6-unrc/._fcntl.h y xv6-mod/._fcntl.h son distintos
Los archivos binarios xv6-unrc/._file.c y xv6-mod/._file.c son distintos
Los archivos binarios xv6-unrc/._file.h y xv6-mod/._file.h son distintos
Los archivos binarios xv6-unrc/._fs.c y xv6-mod/._fs.c son distintos
Los archivos binarios xv6-unrc/._fs.h y xv6-mod/._fs.h son distintos
Los archivos binarios xv6-unrc/._gdbutil y xv6-mod/._gdbutil son distintos
Los archivos binarios xv6-unrc/._ide.c y xv6-mod/._ide.c son distintos
Los archivos binarios xv6-unrc/._initcode.S y xv6-mod/._initcode.S son distintos
Los archivos binarios xv6-unrc/._ioapic.c y xv6-mod/._ioapic.c son distintos
Los archivos binarios xv6-unrc/._kalloc.c y xv6-mod/._kalloc.c son distintos
Los archivos binarios xv6-unrc/._kbd.c y xv6-mod/._kbd.c son distintos
Los archivos binarios xv6-unrc/._kbd.h y xv6-mod/._kbd.h son distintos
Los archivos binarios xv6-unrc/._kernel.ld y xv6-mod/._kernel.ld son distintos
Los archivos binarios xv6-unrc/._lapic.c y xv6-mod/._lapic.c son distintos
Los archivos binarios xv6-unrc/._LICENSE y xv6-mod/._LICENSE son distintos
Los archivos binarios xv6-unrc/._log.c y xv6-mod/._log.c son distintos
Los archivos binarios xv6-unrc/._LucidaSans-Typewriter83~ y xv6-mod/._LucidaSans-Typewriter83~ son distintos
Los archivos binarios xv6-unrc/._main.c y xv6-mod/._main.c son distintos
diff -rupN xv6-unrc/Makefile xv6-mod/Makefile
--- xv6-unrc/Makefile	2018-04-18 17:43:18.445432823 -0300
+++ xv6-mod/Makefile	2018-04-18 19:47:23.903727622 -0300
@@ -32,7 +32,7 @@ OBJS = \
 # TOOLPREFIX = i386-jos-elf
 
 # Using native tools (e.g., on X86 Linux)
-#TOOLPREFIX = 
+#TOOLPREFIX =
 
 # Try to infer the correct TOOLPREFIX if not set
 ifndef TOOLPREFIX
@@ -147,6 +147,12 @@ _forktest: user/forktest.o $(ULIB)
 	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest user/forktest.o user/ulib.o user/usys.o
 	$(OBJDUMP) -S _forktest > forktest.asm
 
+_prioritytest: user/prioritytest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _prioritytest user/prioritytest.o user/ulib.o user/usys.o
+	$(OBJDUMP) -S _prioritytest > prioritytest.asm
+
 mkfs: mkfs.c fs.h
 	gcc -Werror -Wall -o mkfs mkfs.c
 
@@ -160,6 +166,7 @@ UPROGS=\
 	_cat\
 	_echo\
 	_forktest\
+	_prioritytest\
 	_grep\
 	_init\
 	_kill\
@@ -178,7 +185,7 @@ fs.img: mkfs README $(UPROGS)
 
 -include *.d
 
-clean: 
+clean:
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*.o user/*.o *.d user/*.d *.asm *.sym vectors.S bootblock entryother \
 	initcode initcode.out kernel xv6.img fs.img kernelmemfs mkfs \
@@ -239,7 +246,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 # check in that version.
 
 EXTRA=\
-	mkfs.c user/ulib.c user/user.h user/cat.c user/echo.c user/forktest.c user/grep.c user/kill.c\
+	mkfs.c user/ulib.c user/user.h user/cat.c user/echo.c user/forktest.c user/prioritytest.c user/grep.c user/kill.c\
 	user/ln.c user/ls.c user/mkdir.c user/rm.c user/stressfs.c user/usertests.c user/wc.c user/zombie.c\
 	user/printf.c user/umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
Los archivos binarios xv6-unrc/._Makefile y xv6-mod/._Makefile son distintos
Los archivos binarios xv6-unrc/._memide.c y xv6-mod/._memide.c son distintos
Los archivos binarios xv6-unrc/._memlayout.h y xv6-mod/._memlayout.h son distintos
Los archivos binarios xv6-unrc/._mkfs.c y xv6-mod/._mkfs.c son distintos
diff -rupN xv6-unrc/mkfs.c xv6-mod/mkfs.c
--- xv6-unrc/mkfs.c	2018-04-18 17:43:18.445432823 -0300
+++ xv6-mod/mkfs.c	2018-04-18 17:43:18.397432075 -0300
@@ -11,7 +11,7 @@
 #include "stat.h"
 #include "param.h"
 
-#define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
+//#define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
 
 int nblocks = (995-LOGSIZE);
 int nlog = LOGSIZE;
Los archivos binarios xv6-unrc/._mmu.h y xv6-mod/._mmu.h son distintos
Los archivos binarios xv6-unrc/._mp.c y xv6-mod/._mp.c son distintos
Los archivos binarios xv6-unrc/._mp.h y xv6-mod/._mp.h son distintos
Los archivos binarios xv6-unrc/._Notes y xv6-mod/._Notes son distintos
Los archivos binarios xv6-unrc/._param.h y xv6-mod/._param.h son distintos
diff -rupN xv6-unrc/param.h xv6-mod/param.h
--- xv6-unrc/param.h	2018-04-18 17:43:18.449432885 -0300
+++ xv6-mod/param.h	2018-04-19 20:03:51.511518205 -0300
@@ -10,4 +10,9 @@
 #define MAXOPBLOCKS  10  // max # of blocks any FS op writes
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data sectors in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-
+#define TIMESLICE    40  //amount of ticks per burst of execution
+#define MLFLEVELS    4   // amount of levels in the MLF structure
+#define MLFMAXLEVEL  0   // level of maximum priority in the mlf
+#define AGEFORSCALING  50  // age needed to climb the mlf levels
+#define TICKSFORAGING 100  //
+#define ACTIVATEAGING  1 // 1 for activate the priority increase by aging, 0 for disable
Los archivos binarios xv6-unrc/._picirq.c y xv6-mod/._picirq.c son distintos
Los archivos binarios xv6-unrc/._pipe.c y xv6-mod/._pipe.c son distintos
Los archivos binarios xv6-unrc/._printpcs y xv6-mod/._printpcs son distintos
Los archivos binarios xv6-unrc/._proc.c y xv6-mod/._proc.c son distintos
diff -rupN xv6-unrc/proc.c xv6-mod/proc.c
--- xv6-unrc/proc.c	2018-04-18 17:43:18.449432885 -0300
+++ xv6-mod/proc.c	2018-04-19 18:35:40.236332903 -0300
@@ -10,8 +10,11 @@
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
+  struct proc* mlf[MLFLEVELS];
 } ptable;
 
+
+
 static struct proc *initproc;
 
 int nextpid = 1;
@@ -55,11 +58,11 @@ found:
     return 0;
   }
   sp = p->kstack + KSTACKSIZE;
-  
+
   // Leave room for trap frame.
   sp -= sizeof *p->tf;
   p->tf = (struct trapframe*)sp;
-  
+
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
@@ -70,17 +73,56 @@ found:
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
+  //set priority 0 by default
+  p->priority = 0;
+
   return p;
 }
 
 //PAGEBREAK: 32
+
+void
+makerunnable (struct proc* p)
+{
+  int priority;
+  struct proc* lastOfLevel ;
+  p->state = RUNNABLE;
+  p->next=0;
+  p->age=0;
+  priority=p->priority;
+  lastOfLevel = ptable.mlf[priority];
+
+  if(lastOfLevel ==0){   //If the level does not have processes, it saves the process as the first
+    ptable.mlf[priority]=p;
+  }else{
+    while(lastOfLevel->next != 0){ // if not, I take the first and advance until I reach the last
+      lastOfLevel=lastOfLevel->next;
+    }
+    lastOfLevel->next=p;  //and I keep it as the last
+  }
+}
+
+struct proc*
+unqueue(int level)
+{
+  struct proc* res;
+  res=0;
+  if(ptable.mlf[level]!=0){
+    res =ptable.mlf[level];
+    ptable.mlf[level]=ptable.mlf[level]->next;
+    res->next=0;
+  }
+  return res;
+}
+
+
 // Set up first user process.
 void
 userinit(void)
 {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
-  
+
   p = allocproc();
   initproc = p;
   if((p->pgdir = setupkvm()) == 0)
@@ -99,7 +141,9 @@ userinit(void)
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
 
-  p->state = RUNNABLE;
+  //cprintf(" antes make runabbele de userinit \n");
+  makerunnable(p);
+  //cprintf("despues make runabbele de userinit \n");
 }
 
 // Grow current process's memory by n bytes.
@@ -108,7 +152,7 @@ int
 growproc(int n)
 {
   uint sz;
-  
+
   sz = proc->sz;
   if(n > 0){
     if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
@@ -155,14 +199,14 @@ fork(void)
   np->cwd = idup(proc->cwd);
 
   safestrcpy(np->name, proc->name, sizeof(proc->name));
- 
+
   pid = np->pid;
 
   // lock to force the compiler to emit the np->state write last.
   acquire(&ptable.lock);
-  np->state = RUNNABLE;
+  makerunnable(np);
   release(&ptable.lock);
-  
+
   return pid;
 }
 
@@ -266,29 +310,36 @@ void
 scheduler(void)
 {
   struct proc *p;
-
+  int level;
   for(;;){
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
 
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-      swtch(&cpu->scheduler, proc->context);
-      switchkvm();
-
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
-      proc = 0;
+    for(level = MLFMAXLEVEL; level < MLFLEVELS; level++){
+
+      if(ptable.mlf[level] != 0){
+        p = ptable.mlf[level];
+        // Switch to chosen process.  It is the process's job
+        // to release ptable.lock and then reacquire it
+        // before jumping back to us.
+        proc = p;
+        switchuvm(p);
+        p->state = RUNNING;                       //puts in "RUNNING" the chosen process
+        p->timesscheduled++;
+        unqueue(level);
+
+
+        swtch(&cpu->scheduler, proc->context);
+        switchkvm();
+
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        proc = 0;
+        break;
+      }
     }
     release(&ptable.lock);
 
@@ -320,7 +371,10 @@ void
 yield(void)
 {
   acquire(&ptable.lock);  //DOC: yieldlock
-  proc->state = RUNNABLE;
+  if(proc->priority < (MLFLEVELS-1)){
+    proc->priority=(proc->priority)+1;
+  }
+  makerunnable(proc);
   sched();
   release(&ptable.lock);
 }
@@ -336,12 +390,12 @@ forkret(void)
 
   if (first) {
     // Some initialization functions must be run in the context
-    // of a regular process (e.g., they call sleep), and thus cannot 
+    // of a regular process (e.g., they call sleep), and thus cannot
     // be run from main().
     first = 0;
     initlog();
   }
-  
+
   // Return to "caller", actually trapret (see allocproc).
 }
 
@@ -391,8 +445,13 @@ wakeup1(void *chan)
   struct proc *p;
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
-      p->state = RUNNABLE;
+    if(p->state == SLEEPING && p->chan == chan){
+      if(p->priority>MLFMAXLEVEL){
+        p->priority--;
+      }
+      makerunnable(p);
+    }
+
 }
 
 // Wake up all processes sleeping on chan.
@@ -418,7 +477,7 @@ kill(int pid)
       p->killed = 1;
       // Wake process from sleep if necessary.
       if(p->state == SLEEPING)
-        p->state = RUNNABLE;
+        makerunnable(p);
       release(&ptable.lock);
       return 0;
     }
@@ -446,7 +505,7 @@ procdump(void)
   struct proc *p;
   char *state;
   uint pc[10];
-  
+
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->state == UNUSED)
       continue;
@@ -460,6 +519,50 @@ procdump(void)
       for(i=0; i<10 && pc[i] != 0; i++)
         cprintf(" %p", pc[i]);
     }
+    cprintf(" prioridad: %d",p->priority); //shows the priority of the process
+    cprintf(" edad: %d",p->age); //shows the priority of the process
+    cprintf(" sch: %d",p->timesscheduled);
     cprintf("\n");
   }
 }
+
+
+
+void
+raisepriority(int level )         //unqueue, modify the priority and enqueue
+{
+    struct proc* oldprocess;
+    oldprocess = unqueue(level);
+    if(oldprocess){
+      oldprocess->priority = level-1;
+      makerunnable(oldprocess);
+    }
+}
+
+
+void
+aging()
+{
+  struct proc *p;
+  int level;
+  acquire(&ptable.lock);
+  for (level=MLFMAXLEVEL; level < MLFLEVELS; level++) { // i go through the levels of the mlf
+    p =ptable.mlf[level];
+    while(p){
+      p->age++;                             // increase the age
+      if( (p->age == AGEFORSCALING && level != MLFMAXLEVEL)){ // check if the process deserves a priority increase
+        procdump();                         //prints the processes BEFORE the priority increase
+        if(ACTIVATEAGING){                 //ACTIVATEAGING value is in param.h !
+          raisepriority(level);
+          cprintf("---------------------------------\n");
+          procdump();                     //prints the processes AFTER the priority increase
+        }
+        cprintf("//////////////////////////////////////\n");
+        p=ptable.mlf[level];              // now will continue with the new first level process
+      }else{
+        p=p->next;                        //from here only increases the age, because they will be younger
+      }
+    }
+  }
+  release(&ptable.lock);
+}
Los archivos binarios xv6-unrc/._proc.h y xv6-mod/._proc.h son distintos
diff -rupN xv6-unrc/proc.h xv6-mod/proc.h
--- xv6-unrc/proc.h	2018-04-18 17:43:18.449432885 -0300
+++ xv6-mod/proc.h	2018-04-19 18:33:37.117455834 -0300
@@ -10,7 +10,7 @@ struct cpu {
   volatile uint started;       // Has the CPU started?
   int ncli;                    // Depth of pushcli nesting.
   int intena;                  // Were interrupts enabled before pushcli?
-  
+
   // Cpu-local storage variables; see below
   struct cpu *cpu;
   struct proc *proc;           // The currently-running process.
@@ -66,6 +66,11 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  ushort ticks;                // Ticks that have been executed during the execution burst
+  struct proc* next;
+  ushort priority;
+  ushort age;
+  ushort timesscheduled;
 };
 
 // Process memory is laid out contiguously, low addresses first:
Los archivos binarios xv6-unrc/._pr.pl y xv6-mod/._pr.pl son distintos
Los archivos binarios xv6-unrc/._README y xv6-mod/._README son distintos
Los archivos binarios xv6-unrc/._runoff y xv6-mod/._runoff son distintos
Los archivos binarios xv6-unrc/._runoff1 y xv6-mod/._runoff1 son distintos
Los archivos binarios xv6-unrc/._runoff.list y xv6-mod/._runoff.list son distintos
Los archivos binarios xv6-unrc/._runoff.spec y xv6-mod/._runoff.spec son distintos
Los archivos binarios xv6-unrc/._show1 y xv6-mod/._show1 son distintos
Los archivos binarios xv6-unrc/._sign.pl y xv6-mod/._sign.pl son distintos
Los archivos binarios xv6-unrc/._sleep1.p y xv6-mod/._sleep1.p son distintos
Los archivos binarios xv6-unrc/._spinlock.c y xv6-mod/._spinlock.c son distintos
Los archivos binarios xv6-unrc/._spinlock.h y xv6-mod/._spinlock.h son distintos
Los archivos binarios xv6-unrc/._spinp y xv6-mod/._spinp son distintos
Los archivos binarios xv6-unrc/._stat.h y xv6-mod/._stat.h son distintos
Los archivos binarios xv6-unrc/._string.c y xv6-mod/._string.c son distintos
Los archivos binarios xv6-unrc/._swtch.S y xv6-mod/._swtch.S son distintos
Los archivos binarios xv6-unrc/._symlink.patch y xv6-mod/._symlink.patch son distintos
Los archivos binarios xv6-unrc/._syscall.c y xv6-mod/._syscall.c son distintos
diff -rupN xv6-unrc/syscall.c xv6-mod/syscall.c
--- xv6-unrc/syscall.c	2018-04-18 17:43:18.449432885 -0300
+++ xv6-mod/syscall.c	2018-04-18 17:43:18.397432075 -0300
@@ -98,6 +98,8 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_procstat(void);
+extern int sys_setpriority(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -121,6 +123,8 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_procstat] sys_procstat,
+[SYS_setpriority] sys_setpriority,
 };
 
 void
Los archivos binarios xv6-unrc/._syscall.h y xv6-mod/._syscall.h son distintos
diff -rupN xv6-unrc/syscall.h xv6-mod/syscall.h
--- xv6-unrc/syscall.h	2018-04-18 17:43:18.449432885 -0300
+++ xv6-mod/syscall.h	2018-04-18 17:43:18.397432075 -0300
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_procstat  22
+#define SYS_setpriority  23
Los archivos binarios xv6-unrc/._sysfile.c y xv6-mod/._sysfile.c son distintos
Los archivos binarios xv6-unrc/._sysproc.c y xv6-mod/._sysproc.c son distintos
diff -rupN xv6-unrc/sysproc.c xv6-mod/sysproc.c
--- xv6-unrc/sysproc.c	2018-04-18 17:43:18.449432885 -0300
+++ xv6-mod/sysproc.c	2018-04-18 17:43:18.397432075 -0300
@@ -89,3 +89,30 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+//
+int
+sys_procstat(void)  
+{
+  //cprintf("SE EJECUTA EL SYS_PROCSTAT\n");
+  procdump();// ejecutamos la funcion procdump definida en proc.c
+  return 0;
+}
+
+// change the priority of the process to the specified value
+//
+int
+sys_setpriority(void)
+{
+    int priority;
+    if(argint(0, &priority) < 0)
+      return -1;
+    if(priority>=0 &&priority<MLFLEVELS){
+      proc->priority=priority;
+      return 0;
+    }
+    else{
+      return -1;
+    }
+
+}
\ No hay ningún carácter de nueva línea al final del archivo
Los archivos binarios xv6-unrc/._timer.c y xv6-mod/._timer.c son distintos
Los archivos binarios xv6-unrc/._toc.ftr y xv6-mod/._toc.ftr son distintos
Los archivos binarios xv6-unrc/._toc.hdr y xv6-mod/._toc.hdr son distintos
Los archivos binarios xv6-unrc/._trapasm.S y xv6-mod/._trapasm.S son distintos
Los archivos binarios xv6-unrc/._trap.c y xv6-mod/._trap.c son distintos
diff -rupN xv6-unrc/trap.c xv6-mod/trap.c
--- xv6-unrc/trap.c	2018-04-18 17:43:18.449432885 -0300
+++ xv6-mod/trap.c	2018-04-19 12:00:38.545841127 -0300
@@ -22,7 +22,7 @@ tvinit(void)
   for(i = 0; i < 256; i++)
     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
-  
+
   initlock(&tickslock, "time");
 }
 
@@ -77,7 +77,7 @@ trap(struct trapframe *tf)
             cpu->id, tf->cs, tf->eip);
     lapiceoi();
     break;
-   
+
   //PAGEBREAK: 13
   default:
     if(proc == 0 || (tf->cs&3) == 0){
@@ -89,22 +89,32 @@ trap(struct trapframe *tf)
     // In user space, assume process misbehaved.
     cprintf("pid %d %s: trap %d err %d on cpu %d "
             "eip 0x%x addr 0x%x--kill proc\n",
-            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
+            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip,
             rcr2());
     proc->killed = 1;
   }
 
   // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running 
+  // (If it is still executing in the kernel, let it keep running
   // until it gets to the regular system call return.)
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
     exit();
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
-    yield();
+  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER){
+    proc->ticks++;
+    if(proc->ticks % TIMESLICE==0){
+      //cprintf("proceso pid=%d ejecuta el yield en el tick %d \n",proc->pid,proc->ticks);
+      proc->ticks=0;
+      yield();
+    }
+    if(ticks % TICKSFORAGING ==0){
+      //cprintf("ticks = %d pid %d\n",ticks,proc->pid);
+      aging();
+    }
 
+  }
   // Check if the process has been killed since we yielded
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
     exit();
Los archivos binarios xv6-unrc/._traps.h y xv6-mod/._traps.h son distintos
Los archivos binarios xv6-unrc/._TRICKS y xv6-mod/._TRICKS son distintos
Los archivos binarios xv6-unrc/._types.h y xv6-mod/._types.h son distintos
Los archivos binarios xv6-unrc/._uart.c y xv6-mod/._uart.c son distintos
diff -rupN xv6-unrc/user/forktest.c xv6-mod/user/forktest.c
--- xv6-unrc/user/forktest.c	2018-04-18 17:43:18.449432885 -0300
+++ xv6-mod/user/forktest.c	2018-04-18 17:43:18.417432387 -0300
@@ -21,11 +21,14 @@ forktest(void)
   printf(1, "fork test\n");
 
   for(n=0; n<N; n++){
+    if(n==5){     //en la sexta iteracion del ciclo, se ejecuta procstat
+      procstat();
+    }
     pid = fork();
     if(pid < 0)
       break;
     if(pid == 0)
-      exit();
+     exit();
   }
   
   if(n == N){
diff -rupN xv6-unrc/user/param.h xv6-mod/user/param.h
--- xv6-unrc/user/param.h	2018-04-18 17:43:18.449432885 -0300
+++ xv6-mod/user/param.h	2018-04-19 20:03:51.511518205 -0300
@@ -10,4 +10,9 @@
 #define MAXOPBLOCKS  10  // max # of blocks any FS op writes
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data sectors in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-
+#define TIMESLICE    40  //amount of ticks per burst of execution
+#define MLFLEVELS    4   // amount of levels in the MLF structure
+#define MLFMAXLEVEL  0   // level of maximum priority in the mlf
+#define AGEFORSCALING  50  // age needed to climb the mlf levels
+#define TICKSFORAGING 100  //
+#define ACTIVATEAGING  1 // 1 for activate the priority increase by aging, 0 for disable
diff -rupN xv6-unrc/user/prioritytest1.c xv6-mod/user/prioritytest1.c
--- xv6-unrc/user/prioritytest1.c	1969-12-31 21:00:00.000000000 -0300
+++ xv6-mod/user/prioritytest1.c	2018-04-19 10:28:09.139064261 -0300
@@ -0,0 +1,38 @@
+// Test that fork fails gracefully.
+// Tiny executable so that the limit can be filling the proc table.
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+void
+printf(int fd, char *s, ...)
+{
+  write(fd, s, strlen(s));
+}
+
+void
+setprioritytest(void)
+{
+  int pid;
+
+  printf(1, "fork priotity\n");
+  pid = fork();
+  if (pid==0){
+    for (;;){
+      setpriority(0); 
+    }
+  }
+  else{
+    for(;;){
+
+    }
+  }  
+}
+
+int
+main(void)
+{
+  setprioritytest();
+  exit();
+}
diff -rupN xv6-unrc/user/prioritytest.c xv6-mod/user/prioritytest.c
--- xv6-unrc/user/prioritytest.c	1969-12-31 21:00:00.000000000 -0300
+++ xv6-mod/user/prioritytest.c	2018-04-19 19:53:29.907509371 -0300
@@ -0,0 +1,56 @@
+// Test that fork fails gracefully.
+// Tiny executable so that the limit can be filling the proc table.
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define N  1000
+
+void
+printf(int fd, char *s, ...)
+{
+  write(fd, s, strlen(s));
+}
+
+void
+prioritytest(void)
+{
+  int i;
+  int pid;
+  printf(1, "prioritytest\n");
+    fork();
+    for (i=0;i<2;i++){
+      pid=fork();
+
+      if(pid==0){
+        break;
+      }
+    }
+
+    if(pid != 0){
+      for(;;){
+        setpriority(0);
+      }
+    }
+    if(pid == 0){
+        //setpriority(3);
+        for(;;){
+          if(i %2==0){
+            setpriority(2);
+          }
+        }
+      }
+    }
+
+
+
+
+
+
+int
+main(void)
+{
+  prioritytest();
+  exit();
+}
diff -rupN xv6-unrc/user/syscall.h xv6-mod/user/syscall.h
--- xv6-unrc/user/syscall.h	2018-04-18 17:43:18.449432885 -0300
+++ xv6-mod/user/syscall.h	2018-04-18 17:43:18.397432075 -0300
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_procstat  22
+#define SYS_setpriority  23
diff -rupN xv6-unrc/user/user.h xv6-mod/user/user.h
--- xv6-unrc/user/user.h	2018-04-18 17:43:18.449432885 -0300
+++ xv6-mod/user/user.h	2018-04-18 17:43:18.421432449 -0300
@@ -23,6 +23,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int procstat(void);
+void setpriority(int priority);
 
 // ulib.c
 int stat(char*, struct stat*);
diff -rupN xv6-unrc/user/usys.S xv6-mod/user/usys.S
--- xv6-unrc/user/usys.S	2018-04-18 17:43:18.453432947 -0300
+++ xv6-mod/user/usys.S	2018-04-18 17:43:18.421432449 -0300
@@ -29,3 +29,5 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(procstat)
+SYSCALL(setpriority) 
Los archivos binarios xv6-unrc/._user y xv6-mod/._user son distintos
Los archivos binarios xv6-unrc/._vectors.pl y xv6-mod/._vectors.pl son distintos
Los archivos binarios xv6-unrc/._vm.c y xv6-mod/._vm.c son distintos
Los archivos binarios xv6-unrc/._x86.h y xv6-mod/._x86.h son distintos
Los archivos binarios xv6-unrc/._xv6.pdf y xv6-mod/._xv6.pdf son distintos
